<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.3.450">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Trung Dam">
<meta name="dcterms.date" content="2024-04-26">

<title>Tidy Tuesday - NCAA March Madness - Trung Dam</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="tidy-tuesday-ncaa_files/libs/clipboard/clipboard.min.js"></script>
<script src="tidy-tuesday-ncaa_files/libs/quarto-html/quarto.js"></script>
<script src="tidy-tuesday-ncaa_files/libs/quarto-html/popper.min.js"></script>
<script src="tidy-tuesday-ncaa_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="tidy-tuesday-ncaa_files/libs/quarto-html/anchor.min.js"></script>
<link href="tidy-tuesday-ncaa_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="tidy-tuesday-ncaa_files/libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="tidy-tuesday-ncaa_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="tidy-tuesday-ncaa_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="tidy-tuesday-ncaa_files/libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">


</head>

<body class="fullcontent">

<div id="quarto-content" class="page-columns page-rows-contents page-layout-article">

<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Tidy Tuesday - NCAA March Madness - Trung Dam</h1>
</div>



<div class="quarto-title-meta">

    <div>
    <div class="quarto-title-meta-heading">Author</div>
    <div class="quarto-title-meta-contents">
             <p>Trung Dam </p>
          </div>
  </div>
    
    <div>
    <div class="quarto-title-meta-heading">Published</div>
    <div class="quarto-title-meta-contents">
      <p class="date">April 26, 2024</p>
    </div>
  </div>
  
    
  </div>
  

</header>

<p>The data is from 2008 - 2024 for the men’s teams. The year 2020 is not included because the tournament was canceled due to Covid. The first column of almost every dataset displays the year the data is from.</p>
<section id="research-question" class="level1">
<h1>Research Question</h1>
<ol type="1">
<li>Would the amount of times the team make it to a certain round influence the public picks for the time to win a game in that round?</li>
<li>Are teams with more experiences in previous tournaments likely to have champion gene?</li>
</ol>
<div class="cell">
<div class="cell-output-display">
<p><img src="tidy-tuesday-ncaa_files/figure-html/unnamed-chunk-1-1.png" class="img-fluid" width="672"></p>
</div>
<div class="cell-output-display">
<p><img src="tidy-tuesday-ncaa_files/figure-html/unnamed-chunk-1-2.png" class="img-fluid" width="672"></p>
</div>
</div>
<p>The NCAA March Madness is a single-elimination tournament of 64 D1 basketball teams that compete in seven rounds for the national championship. Every year, ESPN and other sport broadcast websites will create an online platform where basketball audiences can submit their “dream” brackets in which they guess which team will advance into the next round and win the biggest award. With the data in hand, I am curious to look at if people consider one team’s historical winning record to make their guesses on how many percentages that team will survive after each round. Two rounds that I decided to look closer at is Round 64 and the Finals. Round 64, in my opinion, is the round where we can detect the “dark horse” of the tournament. The “dark horse” is a term refers to a team that might not do well in the past but can make a big leap/run in the tournament. On the other hands, for the Finals, people tend to pick either their favorite teams or teams that had Finals experience in the past.</p>
</section>
<section id="round-64" class="level1">
<h1>Round 64</h1>
<p>During Round 64, it is understandable that people always go for the safe options to keep their brackets alive. Indeed, the overall trend is teams with better performance in the past would be predicted to survive the first round. However, some peole decided to go with new faces of NCAA 2024. Steston and Grambling St made their debuts this tournament. Dusquenne also made their first return to the tournament since 1977. So do Samford, McNeese, and Wagner. Since these are some teams’ first debuts to the tournament, there wouldn’t be any information on their previous performance. However, people still believe some of the team can be the “dark horse” of the seasons, evidently predicting McNeese and Dusquenne 25% moving to the first round. Dusquenne delivered, beating BYU who was predicted 75% winning the Round 64, and survived the first round after losing to Illinois in the Round 32.</p>
</section>
<section id="finals" class="level1">
<h1>Finals</h1>
<p>For the Finals prediction, many people went with the reigning champion: University of Connecticut. The only team that previously had multiple Finals appearances that was predicted to be in the Finals this year is University of North Carolina. However, they came up short and lost in the Elite Eight. The commonalities among Finals favorite this year are the teams didn’t necessarily have good winning records in the past and their rosters had a lot of quality freshmen. For instance, Purdue University is one of the favorites to win it all despite never making it to the Finals before. Purdue this year, has one of the most dominant D1 basketball player of all time - Zach Edey.</p>
<p>Looking at these two rounds, audience also takes into account of teams’ current roster to make their prediction, not solely based theirs on teams’s historical records. However, it makes complete sense that people would favor their home team or team that historically took home the trophy.</p>
<div class="cell">
<div class="cell-output-display">
<p><img src="tidy-tuesday-ncaa_files/figure-html/unnamed-chunk-2-1.png" class="img-fluid" width="672"></p>
</div>
<div class="cell-output-display">
<p><img src="tidy-tuesday-ncaa_files/figure-html/unnamed-chunk-2-2.png" class="img-fluid" width="672"></p>
</div>
</div>
</section>
<section id="interpretation" class="level1">
<h1>Interpretation</h1>
<p>Experts from PASE and PAKE believe that the more experiences a team have in the tournaments, the more likely for that team to win a championship. The first graph shows that teams such as UNC, Duke University, Gonzaga, or University of Kentucky have the highest chance of winning it all with their rigorous and frequent NCAA experiences. However, looking deeper into the relationship of total games played and total number of championship, I observe that number of games doesn’t necessarily dictate the total of championship won. Evidently, UConn, despite playing fewer games compared to UNC, Duke University, or Kansas University, won more championship. Also, Gonzago hasn’t won any championship despite a rich history in March Madness. Therefore, to fully understand the championship gene in each team, it is helpful to have access to teams’ chemistry, alum system that can help with coaching or player development, and fan base.</p>
</section>

</main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn) {
    const config = {
      allowHTML: true,
      content: contentFn,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start'
    };
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->



</body></html>